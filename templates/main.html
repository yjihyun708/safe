<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Disaster Pose Core Service</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet"/>
  <style>
    body {
      margin: 0; font-family: 'Inter', sans-serif; background: #f0f4f8; color: #1f2937;
      display: flex; flex-direction: column; align-items: center; padding: 2rem;
    }
    h1 {
      font-size: 2rem; margin-bottom: 1rem; color: #2563eb;
    }
    canvas {
      margin: 1rem 0; border-radius: 10px; background: #fff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    #label-container > div {
      font-size: 1rem; margin-top: 0.2rem;
    }
  </style>
</head>
<body>
  <h1>포즈 인식 훈련</h1>
  <div>
    <canvas id="canvas"></canvas>
    <div id="label-container"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>
  <script>
    let model, webcam, ctx, labelContainer, maxPredictions;

    async function init() {
      const tm_model_key = sessionStorage.getItem('modelKey');
      const URL = `https://teachablemachine.withgoogle.com/models/${tm_model_key}/`;
      const modelURL = URL + \"model.json\";
      const metadataURL = URL + \"metadata.json\";

      model = await tmPose.load(modelURL, metadataURL);
      maxPredictions = model.getTotalClasses();

      const size = 300;
      webcam = new tmPose.Webcam(size, size, true);
      await webcam.setup();
      await webcam.play();
      window.requestAnimationFrame(loop);

      const canvas = document.getElementById(\"canvas\");
      canvas.width = size; canvas.height = size;
      ctx = canvas.getContext(\"2d\");
      labelContainer = document.getElementById(\"label-container\");
      for (let i = 0; i < maxPredictions; i++) {
        labelContainer.appendChild(document.createElement(\"div\"));
      }
    }

    async function loop() {
      webcam.update();
      await predict();
      window.requestAnimationFrame(loop);
    }

    var prev_action_time = new Date().getTime();

    async function predict() {
      const { pose, posenetOutput } = await model.estimatePose(webcam.canvas);
      const prediction = await model.predict(posenetOutput);

      let action_index = -1, action_prop = -1;
      for (let i = 0; i < maxPredictions; i++) {
        const classPrediction = prediction[i].className + \": \" + prediction[i].probability.toFixed(2);
        if (prediction[i].probability > action_prop) {
          action_prop = prediction[i].probability;
          action_index = i;
        }
        labelContainer.childNodes[i].innerHTML = classPrediction;
      }

      const cur_action_time = new Date().getTime();
      if (cur_action_time - prev_action_time > 200) {
        prev_action_time = cur_action_time;
        sendAction(action_index);
      }

      drawPose(pose);
    }

    async function sendAction(index) {
      await fetch(`/action?index=${index}`);
    }

    function drawPose(pose) {
      if (webcam.canvas && pose) {
        ctx.drawImage(webcam.canvas, 0, 0);
        const minPartConfidence = 0.5;
        tmPose.drawKeypoints(pose.keypoints, minPartConfidence, ctx);
        tmPose.drawSkeleton(pose.keypoints, minPartConfidence, ctx);
      }
    }

    window.onload = init;
  </script>
</body>
</html>
